/**
 * Clang-Format Service
 * 负责调用 clang-format 生成代码预览和配置文件
 */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { ProcessRunner, CommandResult } from '../../common/process-runner';
import { ErrorHandler, ErrorContext } from '../../common/error-handler';
import { MACRO_PREVIEW_CODE, DEFAULT_CLANG_FORMAT_CONFIG } from './config-options';

export interface FormatResult {
    success: boolean;
    formattedCode: string;
    error?: string;
}

export interface ConfigValidationResult {
    isValid: boolean;
    error?: string;
    warnings?: string[];
}

export class ClangFormatService {
    private tempConfigPath: string;

    constructor() {
        this.tempConfigPath = path.join(os.tmpdir(), '.clang-format-temp');
    }

    /**
     * 格式化代码（用于微观预览）
     */
    async formatMicroPreview(code: string, config: Record<string, any>): Promise<FormatResult> {
        try {
            // 为微观预览创建临时配置
            await this.writeConfigToFile(config);

            const result = await this.runClangFormat(code, this.tempConfigPath);
            return result;
        } catch (error) {
            ErrorHandler.handle(error, {
                operation: 'formatMicroPreview',
                module: 'ClangFormatService',
                showToUser: false,
                logLevel: 'error'
            });

            return {
                success: false,
                formattedCode: code,
                error: error instanceof Error ? error.message : 'Failed to format micro preview'
            };
        }
    }

    /**
     * 格式化完整代码（用于宏观预览）
     */
    async formatMacroPreview(config: Record<string, any>): Promise<FormatResult> {
        try {
            await this.writeConfigToFile(config);

            const result = await this.runClangFormat(MACRO_PREVIEW_CODE, this.tempConfigPath);
            return result;
        } catch (error) {
            ErrorHandler.handle(error, {
                operation: 'formatMacroPreview',
                module: 'ClangFormatService',
                showToUser: false,
                logLevel: 'error'
            });

            return {
                success: false,
                formattedCode: MACRO_PREVIEW_CODE,
                error: error instanceof Error ? error.message : 'Failed to format macro preview'
            };
        }
    }

    /**
     * 验证配置的有效性
     */
    async validateConfig(config: Record<string, any>): Promise<ConfigValidationResult> {
        try {
            // 写入临时配置文件
            await this.writeConfigToFile(config);

            // 使用简单代码测试配置是否有效
            const testCode = 'int main() { return 0; }';
            const result = await this.runClangFormat(testCode, this.tempConfigPath);

            if (result.success) {
                return { isValid: true };
            } else {
                return {
                    isValid: false,
                    error: result.error || 'Unknown configuration error'
                };
            }
        } catch (error) {
            ErrorHandler.handle(error, {
                operation: 'validateConfig',
                module: 'ClangFormatService',
                showToUser: false,
                logLevel: 'error'
            });

            return {
                isValid: false,
                error: error instanceof Error ? error.message : 'Configuration validation failed'
            };
        }
    }

    /**
     * 生成 .clang-format 配置文件内容
     */
    generateConfigFile(config: Record<string, any>): string {
        const lines: string[] = [];

        // 添加注释头
        lines.push('# Generated by Clotho VS Code Extension');
        lines.push('# clang-format configuration file');
        lines.push('---');

        // 排序配置项以获得一致的输出
        const sortedKeys = Object.keys(config).sort();

        for (const key of sortedKeys) {
            const value = config[key];

            if (value !== undefined && value !== null) {
                lines.push(`${key}: ${this.formatConfigValue(value)}`);
            }
        }

        // 不添加 YAML 结束标记，clang-format 不需要
        return lines.join('\n');
    }

    /**
     * 从文件加载配置
     */
    async loadConfigFromFile(filePath: string): Promise<Record<string, any>> {
        try {
            if (!fs.existsSync(filePath)) {
                throw new Error(`Config file not found: ${filePath}`);
            }

            const content = await fs.promises.readFile(filePath, 'utf8');
            return this.parseConfigContent(content);
        } catch (error) {
            ErrorHandler.handle(error, {
                operation: 'loadConfigFromFile',
                module: 'ClangFormatService',
                showToUser: false,
                logLevel: 'error'
            });

            throw error; // Re-throw for caller to handle
        }
    }

    /**
     * 保存配置到文件
     */
    async saveConfigToFile(config: Record<string, any>, filePath: string): Promise<void> {
        try {
            const configContent = this.generateConfigFile(config);

            // 确保目录存在
            const dir = path.dirname(filePath);
            if (!fs.existsSync(dir)) {
                await fs.promises.mkdir(dir, { recursive: true });
            }

            await fs.promises.writeFile(filePath, configContent, 'utf8');
        } catch (error) {
            ErrorHandler.handle(error, {
                operation: 'saveConfigToFile',
                module: 'ClangFormatService',
                showToUser: false,
                logLevel: 'error'
            });

            throw error; // Re-throw for caller to handle
        }
    }

    /**
     * 获取工作区中的 .clang-format 文件路径
     */
    getWorkspaceConfigPath(): string | undefined {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            return undefined;
        }

        // 查找第一个工作区文件夹中的 .clang-format 文件
        const workspaceRoot = workspaceFolders[0].uri.fsPath;
        const configPath = path.join(workspaceRoot, '.clang-format');

        return fs.existsSync(configPath) ? configPath : undefined;
    }

    /**
     * 应用配置到工作区
     */
    async applyConfigToWorkspace(config: Record<string, any>): Promise<void> {
        try {
            const workspaceFolders = vscode.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                throw new Error('No workspace folder is open');
            }

            const workspaceRoot = workspaceFolders[0].uri.fsPath;
            const configPath = path.join(workspaceRoot, '.clang-format');

            await this.saveConfigToFile(config, configPath);

            // 显示成功消息
            vscode.window.showInformationMessage(
                `Clang-format configuration saved to ${configPath}`
            );
        } catch (error) {
            ErrorHandler.handle(error, {
                operation: 'applyConfigToWorkspace',
                module: 'ClangFormatService',
                showToUser: true,
                logLevel: 'error'
            });

            throw error; // Re-throw for caller to handle
        }
    }

    /**
     * 清理临时文件
     */
    async cleanup(): Promise<void> {
        try {
            if (fs.existsSync(this.tempConfigPath)) {
                await fs.promises.unlink(this.tempConfigPath);
            }
        } catch (error) {
            // 忽略清理错误
            console.warn('Failed to cleanup temp config file:', error);
        }
    }

    // 私有方法

    private async writeConfigToFile(config: Record<string, any>): Promise<void> {
        const configContent = this.generateConfigFile(config);

        // 确保使用 UTF-8 编码，避免 BOM 问题
        const buffer = Buffer.from(configContent, 'utf8');
        await fs.promises.writeFile(this.tempConfigPath, buffer);
    }

    private async runClangFormat(code: string, configPath: string): Promise<FormatResult> {
        try {
            // 创建临时源文件
            const tempSourcePath = path.join(os.tmpdir(), `temp-source-${Date.now()}.cpp`);

            // 确保使用 UTF-8 编码，避免 BOM 问题
            const codeBuffer = Buffer.from(code, 'utf8');
            await fs.promises.writeFile(tempSourcePath, codeBuffer);

            // 运行 clang-format，在 Windows 上使用正确的路径格式
            let command: string;
            if (process.platform === 'win32') {
                // Windows 上使用引号包围路径，避免路径中的空格问题
                command = `clang-format --style="file:${configPath}" "${tempSourcePath}"`;
            } else {
                command = `clang-format --style=file:${configPath} "${tempSourcePath}"`;
            }

            const result = await ProcessRunner.runCommandWithDetails(command, {
                timeout: 10000, // 10秒超时
                cwd: path.dirname(tempSourcePath)
            });

            // 清理临时文件
            try {
                await fs.promises.unlink(tempSourcePath);
            } catch (error) {
                // 忽略清理错误
            }

            if (result.exitCode === 0) {
                return {
                    success: true,
                    formattedCode: result.stdout
                };
            } else {
                return {
                    success: false,
                    formattedCode: code, // 返回原始代码
                    error: result.stderr || 'clang-format execution failed'
                };
            }
        } catch (error) {
            return {
                success: false,
                formattedCode: code,
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }

    private formatConfigValue(value: any): string {
        if (typeof value === 'string') {
            return value;
        } else if (typeof value === 'boolean') {
            return value ? 'true' : 'false';
        } else if (typeof value === 'number') {
            return value.toString();
        } else if (Array.isArray(value)) {
            return `[${value.map(v => this.formatConfigValue(v)).join(', ')}]`;
        } else if (typeof value === 'object') {
            const entries = Object.entries(value).map(([k, v]) => `${k}: ${this.formatConfigValue(v)}`);
            return `{ ${entries.join(', ')} }`;
        } else {
            return String(value);
        }
    }

    private parseConfigContent(content: string): Record<string, any> {
        const config: Record<string, any> = {};
        const lines = content.split('\n');

        for (const line of lines) {
            const trimmed = line.trim();

            // 跳过注释和空行
            if (trimmed.startsWith('#') || trimmed === '' || trimmed === '---' || trimmed === '...') {
                continue;
            }

            // 解析配置行
            const colonIndex = trimmed.indexOf(':');
            if (colonIndex > 0) {
                const key = trimmed.substring(0, colonIndex).trim();
                const value = trimmed.substring(colonIndex + 1).trim();

                config[key] = this.parseConfigValue(value);
            }
        }

        return config;
    }

    private parseConfigValue(value: string): any {
        // 布尔值
        if (value === 'true') return true;
        if (value === 'false') return false;

        // 数字
        if (/^\d+$/.test(value)) {
            return parseInt(value, 10);
        }

        // 字符串（移除引号）
        if (value.startsWith('"') && value.endsWith('"')) {
            return value.slice(1, -1);
        }

        // 默认返回字符串
        return value;
    }
}
